## 23. 클로저

### 프로토타입의 특성을 설명하는 문장을 올바르게 일치시키세요.-

<aside>
💡 용어 목록

**[[Environment]]**

**정보 은닉**

**클로저**

</aside>

| A) 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이 때의 중첩 함수를 부르는 단어                         |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| B) 객체의 특정 프로퍼티나 메서드를 감출 목적으로 캡슐화를 사용하기도 하는 것을 칭하는 용어                                                                                        |
| C) 렉시컬 스코프가 가능하려면 함수는 자신이 정의된 환경, 즉 상위 스코프를 기억해야 한다. 따라서 함수는 자신의 내부 슬롯인 이곳에 자신이 정의된 환경, 상위 스코프 참조를 저장한다. |

- 정답
  **[[Environment]] : C**
  **정보 은닉:** B
  **클로저: A**

### 아래 코드를 보고 적절한 답변을 작성하시오-

- 아래 코드에서 클로저는 어떤 함수인가요?
  →
- innerFunc( )의 실행 결과는 무엇인가요?
  →

```jsx
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc();
```

- 정답
  - 아래 코드에서 클로저는 어떤 함수인가요?
    → inner
    : 클로저는 함수 내부에 선언된 변수를 참조하는 함수를 말하는 것이므로
    inner 함수가 outer 함수의 스코프 내에서 선언되어 outer 스코프 내에 있는 변수 x를 참조하기 때문에 클로저는 inner이다.
  - innerFunc( )의 실행 결과는 무엇인가요?
    → 10
    : 클로저는 외부 함수가 종료되어도 외부 함수의 변수를 가지고 있기 때문에 값은 10이다.

### 3. 아래 빈칸에 적절한 단어를 넣으시오 -

```jsx
렉시컬 스코프는
렉시컬 환경의 "외부 렉시컬 환경에 대한 [ A ]"에 저장할 참조 값,

즉 [ B ] 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 [C]된 환경(위치)에 의해 결정되는 것을 말한다.
```

- 정답
  | a   | 참조 |
  | --- | ---- |
  | b   | 상위 |
  | c   | 정의 |

### 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지할 수 있도록 코드를 수정 하시오

- 현재 아래 작성된 코드는 카운트 상태(num 변수의 값)는 increase 함수가 호출되기 전까지 변경되지 않고 유지 되어야 합니다.
  - 그러므로 카운트 상태는 increase 함수만이 변경할 수 있어야 합니다.

```jsx
let num = 0;
// 현재 카운트 상태는 전역 변수를 통해 관리되므로 누구나 접근하고 변경 할 수 있음.

const increase = function () {
  return ++num;
};

console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```

- 힌트

  - 힌트1
    카운트 상태를 지역 변수로 바꾸어 의도치 않은 상태 변경을 방지해야 합니다.
  - 힌트 2
    지역 변수로 바꾸어 의도치 않은 상태 변경을 방지한 후 이전 상태를 유지 시킬 수 있게 클로저를 사용한다

- 정답
  ```jsx
  const increase = (function () {
    // 즉시 실행 함수
    //카운트 상태 변수
    let num = 0;

    // 클로저 : 즉시 실행 함수가 반환한 함수
    return function () {
      ++num;
    };
  })();

  console.log(increase()); //1
  console.log(increase()); //2
  console.log(increase()); //3
  ```
  - 즉시 실행 함수가 호출되고 즉시 실행 함수가 반환한 함수가 increase 변수에 할당된다.
    increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저
  - 즉시 실행함수는 한 번만 실행되므로 increase가 호출될 때마다 num 변수가 재차 초기화될 일은 없을 것이다.
  - 또한 num 변수는 외부에서 직접 접근할 수 없는 은닉된 private 변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요 업음!

### 5. 다음 문장 중 옳은 문장은 모두 몇개인가요?

<aside>
💡 옳은 문장 찾기

1. 함수 객체의 내부 슬록 [[Environment]]에는 함수가 실행된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 저장된다.
2. 상위 스코프의 어떤 식별자도 참조 하지 않는 경우에는 상위 스코프를 기억하지 않아 클로저라고 할 수 없다.
3. 상위 스코프를 참조하고, 외부 함수보다 생명주기가 짧은 함수도 클로저라고 부를 수 있다.
4. 클로저는 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 안전하게 변경하고 유지하기 위해 사용한다.
</aside>

- 정답
  정답 ⇒ 2,4
  해설
  ```jsx
  1. 함수 객체의 내부 슬록 [[Environment]]에는 함수 정의가 평가된 시점, 즉 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 저장된다.
  3. 상위 식별자를 참조하는 것은 클로저이지만 외부 함수보다 짧은 생명 주기를 가지는 중첩 함수는 클로저였지만 일반적인 클로저라고 부를 수는 없다.
  ```
