### DOM

- Document Object Model
- HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API
- 즉 프로퍼티와 메서드를 제공하는 트리 자료구조

## 노드

### HTML 요소와 노드 객체

- HTML 요소는 HTML 문서를 구성하는 개별적인 요소를 의미함.
-

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/55b284af-ec2a-461e-a67e-b834b7af269c/Untitled.png)

1. HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환
2. 이때 HTML 요소의 어트리뷰트가 어트리뷰트 노드
   HTML 요소의 텍스트 콘텐츠는 텍스트 노드로 변환 됨

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/64801b91-fc58-40e0-b632-76ae85e46dc1/Untitled.png)

1. HTML 문서는 HTML 요소들의 집합으로 이뤄지며, HTML 요소는 중첩 관계를 가짐.
   1. HTML의 콘텐츠 영역에는 텍스트뿐만 아니라 다른 HTML 요소도 포함할 수 있음
   <div> 여기가 콘텐츠 영역 </div>
2. HTML 요소 간에는 중첩 관계에 의해 계층적인 부자 관계가 형성되는데 이러한 HTML 요소 간 부자관계를 반영하여 HTML 문서의 구성 요소인 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료 구조로 구성함

### 트리 자료구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/90bcae01-b346-4512-80dd-79177c82b250/Untitled.png)

- 트리 자료구조
  - 노드들의 계층 구조로 이뤄짐
  - 부모 노드와 자식 노드로 구성
  - 노드 간의 계층적 구조를 표현하는 비선형 자료구조
  - 하나의 최상위 노드에서 시작
- 최상위 노드 (= 루트 노드)
  - 부모 노드 없음
  - 0개 이상의 자식 노드를 가짐
- 리프 노드
  - 자식 노드가 없는 노드

<aside>
✅ DOM : 노드 객체들로 구성된 트리 자료 구조

</aside>

- 노드 객체의 트리로 구조화되어 있어 DOM을 **DOM 트리**라고 부르기도 함

### 노드 객체의 타입

```jsx
<!DOCTYPE html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <ul>
        <li id="apple">Apple</li>
        <li id="banana">Banana</li>
        <li id="orange">orange</li>
    </ul>
    <script src="script.js"></script>
</body>
</html>
```

- 위 HTML 문서를 렌더링 엔진이 파싱할 경우 아래와 같은 DOM을 생성
  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/ca481f60-9e7e-4c57-b4b5-7d599926a3a5/Untitled.png)
  \*위 그림에는 공백 텍스트 노드가 생략되어 있으며 HTML 요소 사이의 개행이나 공백은 텍스트 노드가 됨.
  - 위처럼 DOM은 **노드 객체의 계층적 구조**로 구성
  - 노드 객체
    - 종류가 있고 상속 구조를 가짐
    - 총 12개의 종류(노드 타입)이 있음
    - 중요한 노드 타입 4가지
      | 문서 노드
      (document node) | DOM 트리 최상위에 존재하는 루트 노드
      document 객체를 가리킴
      HTML 문서 당 document 객체는 유일 함
      문서 노드 즉, document 객체는 DOM 트리의 루트 노드이므로 DOM 트리의 노드들에 접근하기 위한 진입점 역할을 담당함.
      | 요소, 어트리뷰트, 텍스트 노드에 접근하기 위해서는 문서 노드를 통해야함. |
      | ----------------------------------------------------------------------- | --------------------------- |
      | 요소 노드                                                               |
      | (element node)                                                          | - HTML 요소를 가리키는 객체 |
      - HTML 요소 간의 중첩에 의해 부자 관계를 가지며, 이 부자 관계를 통해 정보 구조화
      - 요소 노드는 문서의 구조를 표현한다고 할 수 있음 |
        | 어트리뷰트 노드
        (attribute node) | - HTML 요소의 어트리뷰트를 가리키는 객체
      - 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어 있음
      - 어트리뷰트 노드는 부모 노드가 없으므로 요소 노드의 형제 노드는 아님 |
        | 텍스트 노드
        (text node) | - HTML 요소의 텍스트를 가리키는 객체
      - 문서의 정보를 표현한다고 할 수 있음
      - 요소 노드의 자식 노드이며, 자식 노드를 더 이상 가질 수 없는 리프 노드임
      - DOM 트리의 최종단
      - 텍스트 노드에 접근하기 위해서는 부모 노드인 요소 노드에 먼저 접근해야 함. |
    -
    ### 노드 객체의 상속 구조
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/7a00706b-8889-4b59-bcde-f6dcd0298141/Untitled.png)
    - DOM을 구성하는 노드 객체는 브라우저 환경에서 추가적으로 제공하는 **`호스트 객체`**
      - 호스트객체?
        - JS 코드가 실행되는 환경에 의해 제공되는 객체
          - window, document와 같이
        - 실행 환경에 따라 다르며 해당 환경이 제공하는 기능을 사용할 수 있게하는 객체
        | 장점                                                                         | 단점                                                |
        | ---------------------------------------------------------------------------- | --------------------------------------------------- |
        | 특정한 플랫폼에 종속되어 있어 해당 플랫폼에서 제공하는 다양한 기능 활용 가능 | 플랫폼에 종속되어 있어 이식성이 낮음                |
        | 다양한 호스트 객체의 존재로 다양한 기능 구현 가능                            | 플랫폼마다 사용법이 다를 수 있으므로 러닝 커브 발생 |
        - 표준 빌트인 객체가 아님
    - 노드 객체도 자바스크립트 객체이므로 프로토타입에 의한 상속 구조를 가짐
      - 더 쉽게 설명해줘
        자바스크립트에서 웹 페이지는 다양한 요소들로 이루어진 하나의 큰 가족과 같습니다. 이러한 요소들은 노드라는 개체로 표현됩니다. 예를 들어, 웹 페이지의 글자, 이미지, 버튼 등이 모두 노드입니다.
        이 노드들은 마치 가족 구성원처럼 서로 상속을 통해 특성을 공유합니다. 즉, 한 노드가 가진 기능이나 특성을 다른 노드도 사용할 수 있습니다. 이런 상속 시스템은 프로토타입이라고 부르는 규칙에 따라 작동합니다.
        예를 들어, 모든 버튼은 '클릭될 때 무슨 일을 할지'와 같은 기본적인 기능을 공유합니다. 이 기능은 버튼 노드의 '부모'나 '조상' 노드에 정의되어 있으며, 모든 버튼 노드는 이를 상속받아 사용할 수 있습니다.
        간단히 말해, 웹 페이지의 모든 요소는 이러한 상속 구조를 통해 필요한 기능을 쉽게 얻고 사용할 수 있는 시스템입니다. 이렇게 함으로써, 코딩을 통한 웹 페이지 조작이 더욱 효율적이고 간단해집니다!
        - 상속을 통한 기능 사용
          ```jsx
          let button = document.createElement("button"); // 버튼 요소 생성
          button.textContent = "클릭하세요"; // 텍스트 설정
          document.body.appendChild(button); // body에 버튼 추가

          button.onclick = function () {
            // 클릭 이벤트 핸들러 설정
            alert("클릭!");
          };
          ```
    - 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속함.
    - HTML 요소의 종류에 따라 고유의 기능을 가지기도 함.
    - `DOM`은 `HTML` 문서의 계층적 구조와 정보를 표현하며 노드 객체의 종류임.
      - 노드 타입에 따라 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공
      - `DOM API`를 통해 HTML 구조나 내용 또는 스타일 등을 동적으로 조작 가능함.

## 39.2. 요소 노드 취득

### id를 이용한 요소 노드 취득

- `Document.prototype.**getElementById**` 메서드 사용
- 인수로 전달된 id 값을 갖는 `첫 번째 요소 노드`만 반환
- 인수로 전달된 id 값을 갖는 HTML 요소가 존재하지 않는 경우 `null` 반환

```jsx
<!DOCTYPE html>
<html>
<body>
    <ul>
        <li id="apple">Apple</li>
        <li id="banana">Banana</li>
        <li id="orange">Orange</li>
    </ul>
    <script>
        // id 값이 banana인 요소 노드를 탐색하여 반환함
        // 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환함
        const $elem = document.getElementById('banana');

        // 취득한 요소 노드의 style.color 프로퍼티 값을 변경함.
        $elem.style.color = 'red';
    </script>
</body>
</html>
```

- HTML 요소에 id 값을 부여하면 id 값과 동일한 이름의 전역 변수가 암묵적으로 선언 되어 해당 노드 객체가 할당되는 부수 효과 발생

```jsx
<body>
  <div id="foo"></div>
  <script>
    // id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가
    할당. console.log(foo === document.getElementById('foo')); // true // 암묵적
    전역으로 생성된 전역 프로퍼티는 삭제되지만 전역 변수는 삭제되지 않는다.
    delete foo; console.log(foo); // <div id="foo"></div>
  </script>
</body>
```

- 단, id 값과 동일한 이름의 전역 변수가 이미 선언되어 있다면 이 전역 변수에 노드 객체가 재할당되지는 않음
  ```jsx
  <body>
    <div id="foo"></div>
    <script>
      let foo = 1; // id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면
      노드 객체가 재할당되지 않는다. console.log(foo); //1
    </script>
  </body>
  ```

### 태그 이름을 이용한 요소 노드 취득

- `Document.prototype` `Element.prototype.**getElementByTagName**` 메서드는
  인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환함
      ```jsx
      <!DOCTYPE html>
      <html>
      <body>
          <ul>
              <li id="apple">Apple</li>
              <li id="banana">Banana</li>
              <li id="orange">Orange</li>
          </ul>
          <script>
              // 태그 이름이 li인 요소 노드를 모두 탐색하여 반환함
              // 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환
              // HTMLCollection 객체는 유사 배열 객체이면서 이터러블임.
              const $elems = document.getElementByTagName('li');

              // 취득한 요소 노드의 style.color 프로퍼티 값을 변경함.
              // HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경함
              [...$elems].forEach(elem => {elem.style.color = 'red';});
          </script>
      </body>
      </html>
      ```
- 함수는 하나의 값만 반환 가능하므로 여러 개의 값을 반환하려면 배열이나 객체와 같은 자료구조에 담아 반환해야 함

### class를 이용한 요소 노드 취득

- `Document.prototype`/`Element.prototype.**getElementByClassName**` 메서드는
  인수로 전달한 class 어트리뷰트 값이 갖는 모든 요소 노드들을 탐색하여 반환함.

```jsx
<!DOCTYPE html>
<html>
<body>
    <ul>
        <li class="fruit">Apple</li>
        <li class="fruit">Banana</li>
        <li class="fruit">Orange</li>
    </ul>
    <script>
        // 태그 이름이 li인 요소 노드를 모두 탐색하여 반환함
        // 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환
        // HTMLCollection 객체는 유사 배열 객체이면서 이터러블임.
        const $elems = document.**getElementByClassName**('fruit');

        // 취득한 요소 노드의 style.color 프로퍼티 값을 변경함.
        // HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경함
        [...$elems].forEach(elem => {elem.style.color = 'red';});
    </script>
</body>
</html>
```

- HTML 문서의 모든 요소 노드 취득을 위해선 getElementsByTagName 메서드의 인수로 \*를 전달함.

```jsx
const $all = document.getElementsByIdTagName("*");
```

- 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우 빈 HTMLCollection 객체를 반환함

+띄어쓰기로

### class를 이용한 요소 노드 취득

- `Document.prototype` `Element.prototype.getElementsByClassName` 메서드는
  인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환함.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="fruit apple">Apple</li>
      <li class="fruit banana">Banana</li>
      <li class="fruit orange">Orange</li>
    </ul>
    <script>
      // class 값이 fruit 인 요소 노드를 모두 탐색하여 HTMLCollection 객체를 담아 반환
      const $elem = document.getElementsByClassName('fruit');

      // 취득한 모든 요소의 CSS color 프로퍼티 값을 변경.
      [...$elem].forEach(elem => {
        elem.style.color = 'red';
      });

      // class 값이 fruit apple 인 요소 노드를 모두 탐색하여 HTMLCollection 객체를 담아 반환
      const $apples = document.getElementsByClassName('fruit apple');

      [...$apples].forEach(elem => {
        elem.style.color = 'blue';
      });
    </script>
  </body>
</html>
```

- 인수로 전달된 클래스 이름을 갖는 요소가 존재하지 않는 경우 getElementByClassName 메서드는 빈 HTMLCollection 객체를 반환

### CSS 선택자를 이용한 요소 노드 취득

- CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법

```jsx
/* 전체 선택자 */
* {
  ...;
}
/* 태그 선택자 */
p {
  ...;
}
/* id 선택자 */
#foo {
  ...;
}
/* 등등 */
```

- `Document.prototype` `Element.prototype.**querySelector**` 메서드는
  인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환 - 요소 노드가 여러 개인 경우 `첫 번째 요소 노드만 반환` - 요소 노드가 존재하지 않는 경우 `null 반환` - 문법에 맞지 않는 경우 `DOMException 에러 발생`
      ```jsx
      <!DOCTYPE html>
      <html>
        <body>
          <ul>
            <li class="fruit apple">Apple</li>
            <li class="fruit banana">Banana</li>
            <li class="fruit orange">Orange</li>
          </ul>
          <script>
            // class 어트리뷰트 값이 banana 인 첫 번째 요소 노드를 탐색하여 반환
            const $elem = document.querySelector('.banana');

            // 취득한 요소 노드의 style.color 프로퍼티 값을 변경
            $elem.style.color = 'red';
          </script>
        </body>
      </html>
      ```
- `Document.prototype` `Element.prototype.querySelectorAll` 메서드는
  인수로 전달한 CSS 선택자를 만족시키는 모든 요소 노드를 탐색하여 반환
- `querySelectorAll` 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 NodeList 객체를 반환함.
  NodeList 객체는 유사 배열 객체이면서 이터러블임. - 인수로 전달한 CSS 선택자를 만족시키는 요소 노드가 존재하지 않는 경우 null 반환 - 인수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생
      ```jsx

      **<!DOCTYPE html>
      <html>
        <body>
          <ul>
            <li class="fruit apple">Apple</li>
            <li class="fruit banana">Banana</li>
            <li class="fruit orange">Orange</li>
          </ul>**
          <script>
            // ul 요소의 자식 요소인 li 요소를 모두 탐색하여 반환
            const $elem = document.querySelectorAll('ul > li');
            // 취득한 요소 노드들은 NodeList 객체에 담겨 반환
            console.log($elem); // NodeList(3) [li.apple, li.banana, li.orange]

            // 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경
            $elem.forEach(elem => {
              elem.style.color = 'red';
            });
          </script>
        **</body>
      </html>**
      ```

      - 모든 요소 노드를 가져오기 위해서는 querySelectorAll 메서드의 인수로 `*`를 전달

      ```jsx
      const $all = document.querySelectorAll('*');
      ```

      - `getElementById`? `querySelector`?

          CSS 선택자 문법을 사용하는 querySelector, querySelectorAll 메서드는 `getElementById`, `getElementsBy***` 메서드보다 다소 느림.

          하지만 CSS 선택자 문법을 사용하면

          1.  좀 더 구체적인 조건으로 요소 노드를 취득할 수 있고
          2. 일관된 방식으로 요소 노드를 취득할 수 있다는 장점이 있다.

          →  id 어트리뷰트가 있는 요소 노드를 취득하는 경우에는 `getElementById` 메서드를 사용하고 그 외의 경우에는 `querySelector`, `querySelectorAll` 메서드를 사용하는 것이 권장된다.


      ### 특정 요소 노드를 취득할 수 있는지 확인

      - `Element.prototype.matches` 메서드는 인수로 전달한 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인
          - 이벤트 위임 사용시에 유용함

          ```jsx
          <!DOCTYPE html>
          <html lang="en">
            <body>
              <ul id="fruits">
                <li class="apple">Apple</li>
                <li class="banana">Banana</li>
                <li class="orange">Orange</li>
              </ul>
              <script>
                const $apple = document.querySelector('.apple');

                // $apple 노드는 #fruits > li.apple 로 취득할 수 있다.
                console.log($apple.matches('#fruits > li.apple')); // true

                // $apple 노드는 #fruits > li.banana 로 취득할 수 없다.
                console.log($apple.matches('#fruits > li.banana')); // false
              </script>
            </body>
          </html>
          ```


## HTMLCollection과 NodeList

- DOM API가 여러 개의 결과 값을 반환하기 위한 DOM 컬랙션 객체
- 두 가지 모두 유사 배열 객체이며 iterable이므로 `for…of 문 혹은 스프레드 문법으로 배열로 변환이 가능함`

  - 유사 배열 객체?
    배열과 비슷한 특성을 갖지만, 정확하게 배열은 아니라는 것을 의미합니다. 여기서 '유사 배열 객체'란, 배열처럼 인덱스로 접근할 수 있고 `length` 속성을 가지고 있지만, 배열의 모든 메소드(예: `push`, `pop`, `slice` 등)를 갖고 있지 않을 수 있는 객체를 말합니다.
  - iterable ?
    'iterable'이라는 것은 해당 객체들이 반복 가능하다는 것을 의미합니다. 즉, 객체를 순회하면서 그 요소들에 하나씩 접근할 수 있다는 것입니다. JavaScript에서 iterable 객체는 `for...of` 루프나 배열의 구조 분해 할당 등을 사용하여 그 요소들을 순회할 수 있습니다.

- HTMLCollection과 NodeList의 중요한 특성은 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 객체라는 것
  - HTMLCollection
    - 언제나 live 객체로 동작
  - NodeList
    - 대부분의 경우 non-live 객체로 동작하지만 경우에 따라 live 객체로 동작할 때가 있음
      - non-live
        노드 객체의 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지

** 뭔소린지 모르겠음 **

### HTMLCollection

- `getElementsByTagName`, `getElementsByClassName` 메서드가 반환하는 HTMLCollection 객체는
  노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 DOM 컬렉션 객체
  ```jsx
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <ul id="fruits">
        <li class="apple">Apple</li>
        <li class="banana">Banana</li>
        <li class="orange">Orange</li>
      </ul>
      <script>
        // class 값이 red 인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환
        const $elems = document.getElementsByClassName('red');
        // 이 시점에 HTMLCollection 객체에는 3개의 요소 노드가 담겨 있다.
        console.log($elems) // HTMLCollection(3) [li.red, li.red, li.red]

        // HTMLCollection 객체의 모든 요소의 class 값을 blue 로 변경
        for (let i = 0; i < $elems.length; i++) {
          $elems[i].className = 'blue';
        }

        // HTMLCollection 객체의 요소가 3개에서 1개로 변경
        console.log($elems); // HTMLCollection(1) [li.red]
      </script>
    </body>
  </html>
  ```
  - 위 코드 대로 실행 시 두 번째 `li` 요소만 class 값이 변경되지 않음
  HTMLCollection 객체는 실시간으로 노드 객체 상태 변경을 반영하여 요소를 제거할 수 있기 때문에 HTMLCollection 객체를 for문으로 순회하면서 노드 객체의 상태를 변경해야 할 때 주의해야 함.
  ```jsx
  // for 문을 역방향으로 순회
  for (let i = $elems.length - 1; i >= 0; i--) {
    $elems[i].className = "blue";
  }

  // while문으로 HTMLCollection에 요소가 남아 있지 않을 때까지 무한 반복
  let i = 0;
  while ($elems.length > i) {
    $elems[i].className = "blue";
  }
  ```
  - 상태가 즉시 반영 되므로 에러가 나기도하지만 이를 해결하기 위해서 배열로 변환해 사용하는 것을 권장 함.
    ```jsx
    [...$elems].forEach((elem) => (elem.className = "blue"));
    ```
  ### NodeList
  `querySelectorAll` 메서드는 DOM 컬랙션 객체인 NodeList 객체 반환
  이 때 NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하지 않는 객체
  ```jsx
  const $elems = document.querySelectorAll(".red");

  $elems.forEach((elem) => (elem.className = "blue"));
  ```
  - NodeList 객체는 대부분의 경우 노드 객체의 상태 변경을 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작
  - childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection 객체와 같이 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의 필요
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li>Apple</li>
        <li>Banana</li>
        <li>Orange</li>
      </ul>
      <script>
        const $fruits = document.getElementById('fruits');

        // childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.
        const { childNodes } = $fruits;
        console.log(childNodes instanceof NodeList); // true

        // $fruits 요소의 자식 노드는 공백 텍스트 노드를 포함해 모두 5개다.
        console.log(childNodes); // NodeList(5) [text, li, text, li, text]

        for (let i = 0; i < childNodes.length; i++) {
          // removeChild 메서드는 $fruits 요소의 자식 노드를 DOM 에서 삭제
          // removeChild 메서드는 호출할 때마다 NodeList 객체인 childNodes 실시간으로 변경
          // 첫 번째, 세 번째, 다섯 번째 요소만 삭제된다.
          $fruits.removeChild(childNodes[i]);
        }

        // $fruits 요소의 모든 자식 노드가 삭제되지 않는다.
        console.log(childNodes); // NodeList(2) [li, li]
      </script>
    </body>
  </html>
  ```
  - **노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장**
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li>Apple</li>
        <li>Banana</li>
        <li>Orange</li>
      </ul>
      <script>
        const $fruits = document.getElementById('fruits');

        // childNodes 프로퍼티는 NodeList 객체(live)를 반환
        const { childNodes } = $fruits

        // 스프레드 문법을 사용하여 NodeList 객체를 배열로 반환
        [...childNodes].forEach(node => {
          $fruits.removeChild(node);
        });

        // $fruits 요소의 모든 자식 노드가 삭제
        console.log(childNodes); // NodeList []
      </script>
    </body>
  </html>
  ```

## 노드 탐색

```jsx
<ul id="fruits">
  <li>Apple</li>
  <li>Banana</li>
  <li>Orange</li>
</ul>
```

- `ul#fruits` 요소는 3개의 자식 요소를 가짐
- `ul#fruits` 요소 노드를 취득한 다음, 자식 노드를 모두 탐색하거나 자식 노드 중 하나만 탐색 가능

- DOM 트리 상의 노드를 탐색할 수 있도록 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공함.
- 노드 탐색 프로퍼티는 모두 접근자 프로퍼티
  - 단, 노드 탐색 프로퍼티는 setter 없이 getter만 존재하여 **`참조만 가능한 읽기 전용 접근자 프로퍼티`**

### 공백 텍스트 노드

- 공백 문자 (스페이스, 탭, 줄바꿈 등)는 텍스트 노드를 생성
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li class="apple">Apple</li>
        <li class="banana">Banana</li>
        <li class="orange">Orange</li>
      </ul>
    </body>
  </html>
  ```
  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/34e4ac4c-3ace-42ab-91c7-a12496215f7b/image.png)
  - 인위적으로 제거하면 생성하지 않지만 가독성이 구려진다
    ```jsx
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    ```
  ### 자식 노드 탐색
  - 자식 노드 탐색에 사용되는 노드 탐색 프로퍼티
  | 프로퍼티                                                                                               | 설명                                                               |
  | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------ |
  | Node.prototype.childNodes                                                                              | - 자식 노드를 모두 탐색하여 DOM 컬랙션 객체인 NodeList에 담아 반환 |
  | - childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드가 포함되어 있을 수도 있음 |
  | Element.prototype.children                                                                             | - 요소 노드만 모두 탐색하여 HTMLCollection에 담아 반환             |
  | - 텍스트노드가 포함되지 않음                                                                           |
  | 프로퍼티                                                          | 설명                             |
  | ----------------------------------------------------------------- | -------------------------------- |
  | Node.prototype.firstChild                                         | - 첫 번째 자식 노드 반환         |
  | - firstChild 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드 |
  | Node.prototype.lastChild                                          | - 마지막 자식 노드 반환          |
  | - lastChild 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드  |
  | Element.prototype.firstElementChild                               | - 첫 번째 자식 요소 노드를 반환. |
  | - firstElementChild 프로퍼티는 요소 노드만 반환                   |
  | Element.prototype.lastElementChild                                | - 마지막 자식 요소 노드를 반환.  |
  | - lastElementChild 프로퍼티는 요소 노드만 반환                    |
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li class="apple">Apple</li>
        <li class="banana">Banana</li>
        <li class="orange">Orange</li>
      </ul>
      <script>
        // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
        const $fruits = document.getElementById('fruits');

        // #fruits 요소의 모든 자식 노드를 탐색한다.
        // childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있다.
        console.log($fruits.childNodes);
        // NodeList(7) [text, li.apple, text, li.banana, text, li.orange, text]

        // #fruits 요소의 모든 자식 노드를 탐색한다.
        // children 프로퍼티가 반환한 HTMLCollection에는 요소 노드만 포함되어 있다.
        console.log($fruits.children);
        // HTMLCollection(3) [li.apple, li.banana, li.orange]

        // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
        // firstChild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
        console.log($fruits.firstChild); // #text

        // #fruits 요소의 마지막 자식 노드를 탐색한다.
        // lastChild 프로퍼티는 텍스트 노드를 반환할 수도 있다.
        console.log($fruits.lastChild); // #text

        // #fruits 요소의 첫 번째 자식 노드를 탐색한다.
        // firstElementChild 프로퍼티는 요소 노드만 반환한다.
        console.log($fruits.firstElementChild); // li.apple

        // #fruits 요소의 마지막 자식 노드를 탐색한다.
        // lastElementChild 프로퍼티는 요소 노드만 반환한다.
        console.log($fruits.lastElementChild); // li.orange
      </script>
    </body>
  </html>
  ```

### 자식 노드 존재 확인

- 자식 노드 존재 확인을 위해 `Node.prototype.hasChildNodes` 메서드 사용
- `hasChildNodes` 메서드는 자식 노드 존재시 true / 아닐 시에 false 반환
- 텍스트 노드를 포함하여 자식 노드의 존재를 확인
- 요소 노드를 확인하려면 `childElementCount`  프로퍼티 사용

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits"></ul>
    <script>
      // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
      const $fruits = document.getElementById('fruits');

      // #fruits 요소에 자식 노드가 존재하는지 확인
      // hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 노드의 존재 확인
      console.log($fruits.hasChildNodes()); // true

      // 자식 노드 중에 텍스트 노드가 아닌 요소 노드가 존재하는지 확인
      console.log(!!$fruits.childElementCount); // 0 -> false
    </script>
  </body>
</html>
```

### 요소 노드의 텍스트 노드 탐색

- 요소 노드의 텍스트 노드는 요소 노드의 자식 노드
  - 즉, 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근 가능
- firstChild 프로퍼티는 텍스트 노드이거나 요소 노드임.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
    <script>
      // 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.
      console.log(document.getElementById('foo').firstChild); // #text
    </script>
  </body>
</html>
```

### 부모 노드 탐색

- `Node.prototype.parentNode` 프로퍼티 사용
- 텍스트 노드는 DOM 트리의 최종단 노드인 리프 노드이므로 부모 노드가 텍스트 노드인 경우는 없음
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li class="apple">Apple</li>
        <li class="banana">Banana</li>
        <li class="orange">Orange</li>
      </ul>
      <script>
        // 노드 탐색의 기점이 되는 .banana 요소 노드를 취득한다.
        const $banana = document.querySelector('.banana');

        // .banana 요소 노드의 부모 노드를 탐색한다.
        console.log($banana.parentNode); // ul#fruits
      </script>
    </body>
  </html>
  ```

### 형제 노드 탐색

| 프로퍼티                                        | 설명                                                                |
| ----------------------------------------------- | ------------------------------------------------------------------- |
| Node.prototype.previousSibling                  | - 부모 노드가 같은 형제 노드 중 자신의 이전 형제 노드 탐색하여 반환 |
| - 요소 노드일수도 있고 텍스트 노드 일 수도 있음 |
| Node.prototype.nextSibling                      | - 부모 노드가 같은 형제 노드 중 자신의 다음 형제 노드 탐색하여 반환 |
| - 요소 노드일수도 있고 텍스트 노드 일 수도 있음 |

| 프로퍼티                                 | 설명                                                                |
| ---------------------------------------- | ------------------------------------------------------------------- |
| Element.prototype.previousElementSibling | - 부모 노드가 같은 형제 노드 중 자신의 이전 형제 노드 탐색하여 반환 |
| - 요소 노드만 반환함                     |
| Element.prototype.nextElementSibling     | - 부모 노드가 같은 형제 노드 중 자신의 다음 형제 노드 탐색하여 반환 |
| - 요소 노드만 반환함                     |

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
    <script>
      // 노드 탐색의 기점이 되는 #fruits 요소 노드를 취득한다.
      const $fruits = document.getElementById('fruits');

      // #fruits 요소의 첫 번째 자식 노드를 탐색
      // firstChild 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수 있다.
      const { firstChild } = $fruits;
      console.log(firstChild); // #text

      // #fruits 요소의 첫 번째 자식 노드(텍스트 노드)의 다음 형제 노드를 탐색
      // nextSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수 있다.
      const { nextSibling } = firstChild;
      console.log(nextSibling); // li.apple

      // li.apple 요소의 이전 형제 노드를 탐색
      // previousSibling 프로퍼티는 요소 노드뿐만 아니라 텍스트 노드를 반환할 수 있다.
      const { previousSibling } = nextSibling;
      console.log(previousSibling); // #text

      // #fruits 요소의 첫 번째 자식 노드를 탐색
      // firstElementChild 프로퍼티는 요소 노드만 반환
      const { firstElementChild } = $fruits;
      console.log(firstElementChild); // li.apple

      // #fruits 요소의 첫 번째 자식 노드(li.apple)의 다음 형제 노드를 탐색
      // nextElementSibling 프로퍼티는 요소 노드만 반환
      const { nextElementSibling } = firstElementChild;
      console.log(nextElementSibling); // li.banana

      // li.banana 요소의 이전 요소 노드를 탐색
      // previousElementSibling 프로퍼티는 요소 노드만 반환
      const { previousElementSibling } = nextElementSibling;
      console.log(previousElementSibling); // li.apple
    </script>
  </body>
</html>
```

## 노드 정보 취득

- 다음과 같은 노드 정보 프로퍼티 사용

| 프로퍼티                | 설명                                                       |
| ----------------------- | ---------------------------------------------------------- |
| Node.prototype.nodeType | - 노드 객체의 종류, 즉 노드 타입을 나타내는 상수를 반환함. |

    - Node.ELEMENT_NODE : 요소 노드 타입을 나타내는 상수 1을 반환
    - Node.TEXT_NODE : 텍스트 노드 타입을 나타내는 상수 3을 반환
    - Node.DOCUMENT_NODE : 문서 노드 타입을 나타내는 상수 9을 반환 |

| Node.prototype.nodeName | - 노드 이름을 문자열로 반환한다. - 요소 노드 : 대문자 문자열로 태그 이름(”UL”, “LI” 등) 반환 - 텍스트 노드 : 문자열 “#text”를 반환 - 문서 노드 : 문자열 “#document”를 반환 |

```jsx
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
    <script>
      // 문서 노드의 노드 정보를 취득
      console.log(document.nodeType); // 9
      console.log(document.nodeName); // #document

      // 요소 노드의 노드 정보를 취득
      const $foo = document.getElementById('foo');
      console.log($foo.nodeType); // 1
      console.log($foo.nodeName); // DIV

      // 텍스트 노드의 노드 정보를 취득
      const $textNode = $foo.firstChild;
      console.log($textNode.nodeType); // 3
      console.log($textNode.nodeName); // #text
    </script>
  </body>
</html>
```

- 쓰는 사례가 있나?

---

여기부터

### 요소 노드의 텍스트 조작

**NodeValue**

- `Node.prototype.nodeValue` setter, getter 모두 존재하는 접근자 프로퍼티
  - `nodeValue` 프로퍼티를 참조하면 노드 객체의 값(텍스트 노드의 텍스트)을 반환
- 문서 노드나 요소 노드는 `nodeValue` 참조하면 `null` 반환함
- 텍스트 노드의 nodeValue 프로퍼티에 값을 할당하면 텍스트 노드의 값, 즉 텍스트를 변경 가smd
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <div id="foo">Hello</div>
      <script>
        // 문서 노드의 nodeValue 프로퍼티를 참조한다.
        console.log(document.nodeValue); // null

        // 요소 노드의 nodeValue 프로퍼티를 참조한다.
        const $foo = document.getElementById('foo');
        console.log($foo.nodeValue); // null

        // 텍스트 노드의 nodeValue 프로퍼티를 참조한다.
        const $textNode = $foo.firstChild;
        console.log($textNode.nodeValue); // Hello
      </script>
    </body>
  </html>
  ```
  ```jsx
  <!DOCTYPE html>
  <html lang="en">
    <body>
      <div id="foo">Hello</div>
      <script>
        // 1. #foo 요소 노드의 자식 노드인 텍스트 노드를 취득한다.
        const $textNode = document.getElementById('foo').firstChild;

        // 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다.
        $textNode.nodeValue = 'World';

        console.log($textNode.nodeValue); // World
      </script>
    </body>
  </html>
  ```

**textContent**

- `Node.prototype.textContent`프로퍼티는 setter, getter 모두 존재하는 접근자 프로퍼티
  - 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.
  - HTML 마크업은 무시하고 모든 텍스트를 반환한다.
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <div id="foo">Hello <span>world!</span></div>
    </body>
    <script>
      // #foo 요소 노드의 텍스트를 모두 취득한다. 이때 HTML 마크업은 무시된다.
      console.log(document.getElementById('foo').textContent); // Hello world!
    </script>
  </html>
  ```
  - 요소 노드의 콘텐츠 영역에 자식 요소 노드가 없고 텍스트만 존재한다면 `firstChild.nodeValue` 와 `textContent` 프로퍼티는 같은 결과를 반환
    - `textContent` 를 사용하는 것이 코드가 더 간단함.
  - 요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가됨
    - 이때 할당한 문자열에 HTML 마크업이 포함되어 있더라도 문자열 그대로 인식되어 텍스트로 취급된다.
    ```jsx
    <!DOCTYPE html>
    <html lang="en">
      <body>
        <div id="foo">Hello <span>world!</span></div>
        <script>
          document.getElementById('foo').textContent = 'Hi <span>there!</span>';
        </script>
      </body>
    </html>
    ```
    ![39b3c040-5571-43c7-84d3-a8d92a1e057f.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/8b7f11fc-642f-4601-8a4c-fba9d316cc9c/39b3c040-5571-43c7-84d3-a8d92a1e057f.png)
  ### DOM 조작
  - 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는 것
  - DOM 조작에 의해 DOM에 새로운 노드가 추가되거나 삭제되면 리플로우와 리페인트가 발생하는 원인이 되므로 성능에 영향을 줌

**innerHTML**

- `Element.prototype.innerHTML` 프로퍼티는 setter, getter 모두 존재하는 접근자 프로퍼티
  - 요소 노드의 콘텐츠 영역 사이에 포함된 모든 `HTML` 마크업을 `문자열`로 반환
  - `innerHTML` 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고
    할당한 문자열의 파싱되어 DOM에 반영
        ```jsx
        <!DOCTYPE html>
        <html>
          <body>
            <ul id="fruits">
              <li class="apple">Apple</li>
            </ul>
          </body>
          <script>
            const $fruits = document.getElementById('fruits');
            <-- 노드 추가 -->
            $fruits.innerHTML += '<li class="banana">Banana</li>';

            <-- 노드 교체 -->
            $fruits.innerHTML = '<li class="orange">Orange</li>';

            <-- 노드 삭제 -->
            $fruits.innerHTML = '';
          </script>
        </html>
        ```
  - `단점`
    - 크로스 사이트 스크립트 공격에 취약
    - 모든 자식 요소를 제거하고 할당하므로 비효율적
    - 새로운 요소를 삽입할 때 위치를 지정할 수 없음.
  **insertAdjacentHTML**
  - `Element.prototype.insertAdjacentHTML(position, DOMString)`
  - 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입
  - 첫 번재 인수로 위치를 지정한다 (`beforebegin`, `afterbegin`, `beforend`, `afterend`)
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <!--    beforebegin-->
      <div id="foo">
        <!--    afterbegin-->
        text
        <!--    beforeend-->
      </div>
      <!--    afterend-->
    </body>
    <script>
      const $foo = document.getElementById('foo')

      $foo.insertAdjacentHTML('beforebegin', '<p>beforebigin</p>')
      $foo.insertAdjacentHTML('afterbegin', '<p>afterbigin</p>')
      $foo.insertAdjacentHTML('beforeend', '<p>beforeend</p>')
      $foo.insertAdjacentHTML('afterend', '<p>afterend</p>')
    </script>
  </html>
  ```
  - 새롭게 삽입될 요소만 파싱하여 자식 요소로 추가
  - 기존의 자식 노드를 모두 제거하고 다시 처음부터 새롭게 자식 노드 생성
  - 자식 요소를 추가하는 innerHTML 프로퍼티보다 효율적이고 빠름
  - 여전히 크로스 사이트 스크립팅 공격에 취약함.

### 노드 생성과 추가

- DOM은 노드를 직접 생성/삽입/삭제/치환하는 메서드도 제공

**요소 노드 생성**

- **`Document.prototype.createElement(tagName)`** 메서드는 요소 노드를 생성하여 반환한다.

```jsx
// 1. 요소 노드 생성
const $li = document.createElement("li");
// 생성된 요소 노드는 아무런 자식 노드가 없다.
console.log($li.childNodes); // NodeList []
```

**텍스트 노드 생성**

- **`Document.prototype.createTextNode(text)`** 메서드는 텍스트 노드를 생성하여 반환한다.

```jsx
// 2. 텍스트 노드 생성
const textNode = document.createTextNode("Banana");
```

- createTextNode 메서드는 텍스트 노드를 생성할 뿐 요소 노드에 추가하지는 않음
  → 이후에 생성된 텍스트 노드를 요소 노드에 추가하는 처리가 별도로 필요하다.

**텍스트 노드를 요소 노드의 자식 노드로 추가**

- `Node.prototype.appendChild(childNode)` 메서드는 매개변수 childNode에게 인수로 전달한 노드를 appendChild 메서드를 호출한 노드의 마지막 자식 노드로 추가

```jsx
// 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
$li.appendChild(textNode);
```

- 요소 노드에 자식 노드가 하나도 없는 경우
  텍스트 노드를 생성해 요소 노드의 자식 노드로 텍스트 노드로 추가하는 것보다
  textContent 프로퍼티 사용하는 것이 더 간편

```jsx
// 텍스트 노드를 생성하여 요소 노드의 자식 노드로 추가
$li.appendChild(document.createTextnode("Banana"));

// $li 요소 노드에 자식 노드가 하나도 없는 위 코드와 동일하게 동작
$li.textContent = "Banana";
```

→ 그러나 요소 노드에 자식 노드가 있는 경우 요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가되므로 주의

**요소 노드를 돔에 추가**

- `Node.prototype.appendChild` 메서드를 사용하여
  텍스트 노드와 부자 관계로 연결한 요소 노드를 `#fruits` 요소 노드의 마지막 자식 요소로 추가

```jsx
// 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
$fruits.appendChild($li);
```

- 단 하나의 요소 노드를 생성하여 DOM에 한번 추가하므로 DOM은 한 번 변경
  → 리플로우와 리페인트가 실행

### 노드 삽입

1. 마지막 노드 추가

   1. `Node.prototype.appendChild` 메서드는 인수로 전달받은 노드를
      자신을 호출한 노드의 마지막 자식 노드로 DOM에 추가
   2. 노드를 추가할 위치를 지정할 수 없고 언제나 마지막 자식 노드로 추가

   ```jsx
   <!DOCTYPE html>
   <html>
     <body>
       <ul id="fruits">
         <li>Apple</li>
         <li>Banana</li>
       </ul>
     </body>
     <script>
       // 요소 노드 생성
       const $li = document.createElement('li');

       // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가
       $li.appendChild(document.createTextNode('Orange'));

       // $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
       document.getElementById('fruits').appendChild($li);
     </script>
   </html>
   ```

2. 지정한 위치에 노드 삽d입

   1. `Node.prototype.insertBefore(newNode, childNode)` 메서드는
      첫 번째 인수로 전달받은 노드를 두 번째 인수로 전달받은 노드 앞에 삽입

   ```jsx
   <!DOCTYPE html>
   <html>
     <body>
       <ul id="fruits">
         <li>Apple</li>
         <li>Banana</li>
       </ul>
     </body>
     <script>
       const $fruits = document.getElementById('fruits');

       // 요소 노드 생성
       const $li = document.createElement('li');

       // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가
       $li.appendChild(document.createTextNode('Orange'));

       // $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
       $fruits.insertBefore($li, $fruits.lastElementChild);
       // Apple - Orange - Banana
     </script>
   </html>
   ```

   - 두 번째 인수로 전달받은 노드는 반드시 insertBefore 메서드를 호출한 노드의 자식 노드이어야 함
     - 그렇지 않으면 DOMException이 발생
   - 두 번째 인수로 전달받은 노드가 null이면
     - 첫 번째 인수로 전달받은 노드를 insertBefore 메서드를 호출한 노드의 마지막 자식 노드로 추가 → appendChild 메서드처럼 동작
     ```jsx
     <!DOCTYPE html>
     <html>
       <body>
         <ul id="fruits">
           <li>Apple</li>
           <li>Banana</li>
         </ul>
       </body>
       <script>
         const $fruits = document.getElementById('fruits')

         // 요소 노드 생성
         const $li = document.createElement('li')

         // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가
         $li.appendChild(document.createTextNode('Orange'))

         // 두 번째 인수로 전달받은 노드는 반드시 #fruits 요소 노드의 자식 노드이어야 한다.
         $fruits.insertBefore($li, document.querySelector('div')); // DOMException
         // null 이면 apppendChild 메서드 처럼 동작
         $fruits.insertBefore($li, null);
       </script>
     </html>
     ```

### 노드 이동

1.  DOM에 이미 존재하는 노드를 appendChild 또는 insertBefore 메서드를 사용하여 DOM에 다시 추가하면 현재 위치에서 노드를 제거하고 새로운 위치에 노드를 추가
    → 노드가 이동함.
        ```jsx
        <!DOCTYPE html>
        <html>
          <body>
            <ul id="fruits">
              <li>Apple</li>
              <li>Banana</li>
            </ul>
          </body>
          <script>
            const $fruits = document.getElementById('fruits');

            // 이미 존재하는 요소 노드를 취득
            const [$apple, $banana, ] = $fruits.children;

            // 이미 존재하는 $apple 요소 노드를 #fruits 요소 노드의 마지막 노드로 이동
            $fruits.appendChild($apple); // Banana - Orange - Apple

            // 이미 존재하는 $banana 요소 노드를 #fruits 요소의 마지막 자식 노드 앞으로 이동
            $fruits.insertBefore($banana, $fruits.lastElementChild);
            // Orange - Banana - Apple
          </script>
        출처: https://ghost4551.tistory.com/221 [프론트엔드 개발자의 기록 공간:티스토리]
        </html>
        ```

### 노드 복사

- `Node.prototype.cloneNode([deep: true | false])` 메서드는 노드의 사본을 생성하여 반환
- 매개변수 deep에 true를 인수 전달하면 노드를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성
- 얕은 복사로 생성된 요소 노드는 자손 노드를 복사하지 않으므로 텍스트 노드도 없음
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li>Apple</li>
        <li>Banana</li>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');
      const $apple = $fruits.firstElementChild;

      // $apple 요소를 얕은 복사하여 사본을 생성. 텍스트 노드가 없는 사본이 생성
      const $shallowClone = $apple.cloneNode();
      // 사본 요소 노드에 텍스트 추가
      $shallowClone.textContent = 'Banana';
      // 사본 요소 노드를 #fruits 요소 노드의 마지막 노드로 추가
      $fruits.appendChild($shallowClone);

      // #fruits 요소를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성
      const $deepClone = $fruits.cloneNode(true);
      // 사본 요소 노드를 #fruits 요소 노드의 마지막 노드로 추가
      $fruits.appendChild($deepClone);
    </script>
  </html>
  ```

![ae8f64f6-8b8f-45c3-b765-d62fdb672981.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7ad86236-f6d6-4580-b6eb-a551d5eb5146/51fd0253-5a0c-43e7-bd6d-91d08da02080/ae8f64f6-8b8f-45c3-b765-d62fdb672981.png)

### 노드 교체

- `Node.prototype.replaceChild(newChild, oldChild)` 메서드는 자신을 호출한 노드의 자식 노드를 다른 노드로 교체
- 첫 번째 매개변수 newChild에는 교체할 새로운 노드를 인수로 전달하고,
  두 번째 매개변수 oldChild에는 이미 존재하는 교체될 노드를 인수로 전달
- oldChild 매개변수에 인수로 전달한 노드는 replaceChild 메서드를 호출한 노드의 자식 노드이어야 함
  → replaceChild 메서드는 자신을 호출한 노드의 자식 노드인 oldChild 노드를 newChild 노드로 교체
  ```jsx
  <!DOCTYPE html>
  <html>
    <body>
      <ul id="fruits">
        <li>Apple</li>
      </ul>
    </body>
    <script>
      const $fruits = document.getElementById('fruits');

      // 기존 노드와 교체할 요소 노드를 생성
      const $newChild = document.createElement('li');
      $newChild.textContent = 'Banana';

      // #fruits 요소 노드의 첫 번째 요소 노드를 $newChild 요소 노드로 교체
      $fruits.replaceChild($newChild, $fruits.firstElementChild);
    </script>
  </html>
  ```

### 노드 삭제

- `Node.prototype.removeChild(child)` 메서드는 child 매개변수에 인수로 전달한 노드를 DOM에서 삭제
- 인수로 전달한 노드는 removeChild 메서드를 호출한 노드의 자식 노드이어야 함.

## 어트리뷰트

### **어트리뷰트 노드와 attributes 프로퍼티**

- HTML 문서의 구성 요소인 HTML 요소는 여러 개의 어트리뷰트를 가질 수 있음
- HTML 요소의 동작을 제어하기 위한 추가적인 정보를 제공하는  HTML 어트리뷰트는 HTML 요소의 시작 태그에 `어트리뷰트 이름="어트리뷰트 값"` 형식으로 정의

```jsx
<input id="user" type="text" value="Sunny" />
```

- 요소 노드의 모든 어트리뷰트는 요소 노드의 `Element.prototype.attributes` 프로퍼티로 취득 가능
- attributes 프로퍼티는 getter만 존재하는 읽기 전용 접근자 프로퍼티
- 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴 NamedNodeMap 객체를 반환한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <input id="user" type="text" value="sunny" />
    <script>
      // 요소 노드의 attribute 프로퍼티는 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴
      // NamedNodeMap 객체를 반환한다.
      const { attributes } = document.getElementById('user');
      console.log(attributes);

      // 어트리뷰트 값 취득
      console.log(attributes.id.value); // user
      console.log(attributes.type.value); // text
      console.log(attributes.value.value); // sunny
    </script>
  </body>
</html>
```

- {
  "0": {},
  "1": {},
  "2": {}
  }

### HTML 어트리뷰트 조작

- `Element.prototype.getAttribute/setAttribute` 메서드를 사용하면
  attributes 프로퍼티를 통하지 않고 요소 노드에서 메서드를 통해
  직접 HTML 어트리뷰트 값을 취득하거나 변경할 수 있어서 편리함

```jsx
<!DOCTYPE html>
<html>
  <body>
    <input id="user" type="text" value="sunny" />
    <script>
      const $input = document.getElementById('user');

      // value 어트리뷰트 값을 취득
      const inputValue = $input.getAttribute('value');
      console.log(inputValue); // sunny

      // value 어트리뷰트 값을 변경
      $input.setAttribute('value', 'foo');
      console.log($input.getAttribute('value')); // foo
    </script>
  </body>
</html>
```

- `Element.prototype.getAttirbute(attributeName)` : 어트리뷰트 값을 참조(취득)
- `Element.prototype.setAttirbute(attributeName, attributeValue)` : 어트리뷰트 값을 변경

```jsx
<!DOCTYPE html>
<html lang="en">
  <body>
    <input id="user" type="text" value="sunny" />
    <script>
      const $input = document.getElementById('user');

      // value 어트리뷰트의 존재 확인
      if ($input.hasAttribute('value')) {
        // value 어트리뷰트 삭제
        $input.removeAttribute('value');
      }

      // value 어트리뷰트가 삭제되었다.
      console.log($input.hasAttribute('value')); // false
    </script>
  </body>
</html>
```

- `Element.prototype.hasAttirbute(attributeName)` : 어트리뷰트 존재하는지 확인
- `Element.prototype.removeAttirbute(attributeName)` : 특정 어트리뷰트 삭제

### **HTML 어트리뷰트 vs DOM 프로퍼티**

- 요소 노드 객체에는 HTML 어트리뷰트에 대응하는 프로퍼티(DOM 프로퍼티)가 존재
- **HTML 어트리뷰트의 역할은 HTML 요소의 초기 상태를 지정하는 것**
  - **즉, HTML 어트리뷰트 값은 HTML 요소의 초기 상태를 의미하며 이는 불변함**
- **요소 노드는 2개의 상태, 즉 초기 상태와 최신 상태를 관리해야 함.
  요소 노드의 초기 상태는 어트리뷰트 노드가 관리하며, 요소 노드의 최신 상태는 DOM 프로퍼티가 관리**

```jsx
<!DOCTYPE html>
<html>
<body>
  <input id="user" type="text" value="ungmo2">
  <script>
    const $input = document.getElementById('user');

    // attributes 프로퍼티에 저장된 value 어트리뷰트 값
    console.log($input.getAttribute('value')); // ungmo2

    // 요소 노드의 value 프로퍼티에 저장된 value 어트리뷰트 값
    console.log($input.value); // ungmo2
  </script>
</body>
</html>
```

1. 위의 예제를 보면 input value의 초기값은 "ungmo2"
2. 사용자의 입력으로 "foo" 등과 같이 다른 문자열을 입력하면 value의 값이 바뀜.
3. "foo"는 최신 상태이다. 그리고 새로 고침을 하면 다시 "ungmo2"가 된다.

- DOM 프로퍼티의 역할은 사용자의 입력에 의한 상태 변화에 반응하여 언제나 최신 상태를 유지하는 것

### **HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계**

- 대부분의 어트리뷰트는 HTML 어트리뷰트 이름과 동일한 DOM 프로퍼티와 1:1로 대응함.
- 단, 언제나 1:1로 대응하는 것은 아니며 HTML 어트리뷰트 이름과 DOM프로퍼티 키가 반드시 일치하는 것도 아님.

1. id 어트리뷰트와 id 프로퍼티는 1:1 대응하며, 동일한 값으로 연동한다.
2. input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 대응한다. 하지만
   value 어트리뷰트는 초기 상태를, value 프로퍼티는 최신 상태를 갖는다.
3. [cl](http://3.cl)ass 어트리뷰트는 className, classList 프로퍼티와 대응한다.
4. for 어트리뷰트는 htmlFor 프로퍼티와 1:1 대응한다.
5. td 요소의 colspan 어트리뷰트는 대응하는 프로퍼티가 존재하지 않는다.
6. textContent 프로퍼티는 대응하는 어트리뷰트가 존재하지 않는다.
7. 어트리뷰트 이름은 대소문자를 구별하지 않지만 대응하는 프로퍼티 키는 카멜케이스를 따른다.

### DOM 프로퍼티 값의 타입

- getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열
- DOM 프로퍼티로 취득한 값은 문자열이 아닐 수도 있음
  - checkbox 요소의 checked 어트리뷰트 값은 문자열이지만 checked 프로퍼티 값은 불리언 타입.

### **data 어트리뷰트와 dataset 프로퍼티**

- 사용자 정의 어트리뷰트
- data-사용자정의 어트리뷰트 이름 = "값" 형식으로 선언
- HTMLElement.dataset 프로퍼티는 모든 data 어트리뷰트를 담은 DOMStringMap 객체 반환
- DOMStringMap 객체는 사용자정의 어트리뷰트 이름을 카멜케이스로 변환한 프로퍼티를 갖는다

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li data-user-id="1" data-sex="male">John</li>
      <li data-user-id="2" data-sex="female">May</li>
    </ul>
    <script>
      const users = [...document.querySelector('ul').children];
      const 여자 = users.find(x => x.dataset.sex==='female');
      console.log(여자.textContent); // May
      console.log(여자.dataset.userId); // 2
    </script>
  </body>
</html>
```

## 스타일

### 인라인 스타일 조작

- HTMLElement.prototype.style 프로퍼티로 조작 가능
- getter,setter 둘다 있는 접근자 프로퍼티
- 요소 노드의 인라인 스타일을 취득
- style 프로퍼티 참조시 CSSStyleDeclaration 객체 반환
- CSSStyleDeclaration 객체의 프로퍼티는 카멜케이스, CSS는 케밥 케이스
- 프로퍼티에 값 할당시 인라인 스타일로 추가됨
- 단위 지정이 필요한 CSS 프로퍼티에 단위 없으면 적용X

```jsx
<!DOCTYPE html>
<html>
  <body>
   <div style="width: 100px; height : 100px; background-color : red;"></div>
    <script>
      const $div = document.querySelector('div');
      console.log($div.style); // CSSStyleDeclaration 객체
      $div.style.backgroundColor = 'blue'; // 파란색으로 변환
      $div.style['background-color'] = 'green'; // css 표기법으로 적용하고 싶을 때
    </script>
  </body>
</html>
```

- {
  "0": "width",
  "1": "height",
  "2": "background-color",
  "accentColor": "",
  "additiveSymbols": "",
  "alignContent": "",
  "alignItems": "",
  "alignSelf": "",
  "alignmentBaseline": "",
  "all": "",
  "anchorName": "",
  "animation": "",
  "animationComposition": "",
  "animationDelay": "",
  "animationDirection": "",
  "animationDuration": "",
  "animationFillMode": "",
  "animationIterationCount": "",
  "animationName": "",
  "animationPlayState": "",
  "animationRange": "",
  "animationRangeEnd": "",
  "animationRangeStart": "",
  "animationTimeline": "",
  "animationTimingFunction": "",
  "appRegion": "",
  "appearance": "",
  "ascentOverride": "",
  "aspectRatio": "",
  "backdropFilter": "",
  "backfaceVisibility": "",
  "background": "",
  "backgroundAttachment": "",
  "backgroundBlendMode": "",
  "backgroundClip": "",
  "backgroundColor": "green",
  "backgroundImage": "",
  "backgroundOrigin": "",
  "backgroundPosition": "",
  "backgroundPositionX": "",
  "backgroundPositionY": "",
  "backgroundRepeat": "",
  "backgroundSize": "",
  "basePalette": "",
  "baselineShift": "",
  "baselineSource": "",
  "blockSize": "",
  "border": "",
  "borderBlock": "",
  "borderBlockColor": "",
  "borderBlockEnd": "",
  "borderBlockEndColor": "",
  "borderBlockEndStyle": "",
  "borderBlockEndWidth": "",
  "borderBlockStart": "",
  "borderBlockStartColor": "",
  "borderBlockStartStyle": "",
  "borderBlockStartWidth": "",
  "borderBlockStyle": "",
  "borderBlockWidth": "",
  "borderBottom": "",
  "borderBottomColor": "",
  "borderBottomLeftRadius": "",
  "borderBottomRightRadius": "",
  "borderBottomStyle": "",
  "borderBottomWidth": "",
  "borderCollapse": "",
  "borderColor": "",
  "borderEndEndRadius": "",
  "borderEndStartRadius": "",
  "borderImage": "",
  "borderImageOutset": "",
  "borderImageRepeat": "",
  "borderImageSlice": "",
  "borderImageSource": "",
  "borderImageWidth": "",
  "borderInline": "",
  "borderInlineColor": "",
  "borderInlineEnd": "",
  "borderInlineEndColor": "",
  "borderInlineEndStyle": "",
  "borderInlineEndWidth": "",
  "borderInlineStart": "",
  "borderInlineStartColor": "",
  "borderInlineStartStyle": "",
  "borderInlineStartWidth": "",
  "borderInlineStyle": "",
  "borderInlineWidth": "",
  "borderLeft": "",
  "borderLeftColor": "",
  "borderLeftStyle": "",
  "borderLeftWidth": "",
  "borderRadius": "",
  "borderRight": "",
  "borderRightColor": "",
  "borderRightStyle": "",
  "borderRightWidth": "",
  "borderSpacing": "",
  "borderStartEndRadius": "",
  "borderStartStartRadius": "",
  "borderStyle": "",
  "borderTop": "",
  "borderTopColor": "",
  "borderTopLeftRadius": "",
  "borderTopRightRadius": "",
  "borderTopStyle": "",
  "borderTopWidth": "",
  "borderWidth": "",
  "bottom": "",
  "boxShadow": "",
  "boxSizing": "",
  "breakAfter": "",
  "breakBefore": "",
  "breakInside": "",
  "bufferedRendering": "",
  "captionSide": "",
  "caretColor": "",
  "clear": "",
  "clip": "",
  "clipPath": "",
  "clipRule": "",
  "color": "",
  "colorInterpolation": "",
  "colorInterpolationFilters": "",
  "colorRendering": "",
  "colorScheme": "",
  "columnCount": "",
  "columnFill": "",
  "columnGap": "",
  "columnRule": "",
  "columnRuleColor": "",
  "columnRuleStyle": "",
  "columnRuleWidth": "",
  "columnSpan": "",
  "columnWidth": "",
  "columns": "",
  "contain": "",
  "containIntrinsicBlockSize": "",
  "containIntrinsicHeight": "",
  "containIntrinsicInlineSize": "",
  "containIntrinsicSize": "",
  "containIntrinsicWidth": "",
  "container": "",
  "containerName": "",
  "containerType": "",
  "content": "",
  "contentVisibility": "",
  "counterIncrement": "",
  "counterReset": "",
  "counterSet": "",
  "cursor": "",
  "cx": "",
  "cy": "",
  "d": "",
  "descentOverride": "",
  "direction": "",
  "display": "",
  "dominantBaseline": "",
  "emptyCells": "",
  "fallback": "",
  "fieldSizing": "",
  "fill": "",
  "fillOpacity": "",
  "fillRule": "",
  "filter": "",
  "flex": "",
  "flexBasis": "",
  "flexDirection": "",
  "flexFlow": "",
  "flexGrow": "",
  "flexShrink": "",
  "flexWrap": "",
  "float": "",
  "floodColor": "",
  "floodOpacity": "",
  "font": "",
  "fontDisplay": "",
  "fontFamily": "",
  "fontFeatureSettings": "",
  "fontKerning": "",
  "fontOpticalSizing": "",
  "fontPalette": "",
  "fontSize": "",
  "fontStretch": "",
  "fontStyle": "",
  "fontSynthesis": "",
  "fontSynthesisSmallCaps": "",
  "fontSynthesisStyle": "",
  "fontSynthesisWeight": "",
  "fontVariant": "",
  "fontVariantAlternates": "",
  "fontVariantCaps": "",
  "fontVariantEastAsian": "",
  "fontVariantLigatures": "",
  "fontVariantNumeric": "",
  "fontVariantPosition": "",
  "fontVariationSettings": "",
  "fontWeight": "",
  "forcedColorAdjust": "",
  "gap": "",
  "grid": "",
  "gridArea": "",
  "gridAutoColumns": "",
  "gridAutoFlow": "",
  "gridAutoRows": "",
  "gridColumn": "",
  "gridColumnEnd": "",
  "gridColumnGap": "",
  "gridColumnStart": "",
  "gridGap": "",
  "gridRow": "",
  "gridRowEnd": "",
  "gridRowGap": "",
  "gridRowStart": "",
  "gridTemplate": "",
  "gridTemplateAreas": "",
  "gridTemplateColumns": "",
  "gridTemplateRows": "",
  "height": "100px",
  "hyphenateCharacter": "",
  "hyphenateLimitChars": "",
  "hyphens": "",
  "imageOrientation": "",
  "imageRendering": "",
  "inherits": "",
  "initialLetter": "",
  "initialValue": "",
  "inlineSize": "",
  "inset": "",
  "insetArea": "",
  "insetBlock": "",
  "insetBlockEnd": "",
  "insetBlockStart": "",
  "insetInline": "",
  "insetInlineEnd": "",
  "insetInlineStart": "",
  "isolation": "",
  "justifyContent": "",
  "justifyItems": "",
  "justifySelf": "",
  "left": "",
  "letterSpacing": "",
  "lightingColor": "",
  "lineBreak": "",
  "lineGapOverride": "",
  "lineHeight": "",
  "listStyle": "",
  "listStyleImage": "",
  "listStylePosition": "",
  "listStyleType": "",
  "margin": "",
  "marginBlock": "",
  "marginBlockEnd": "",
  "marginBlockStart": "",
  "marginBottom": "",
  "marginInline": "",
  "marginInlineEnd": "",
  "marginInlineStart": "",
  "marginLeft": "",
  "marginRight": "",
  "marginTop": "",
  "marker": "",
  "markerEnd": "",
  "markerMid": "",
  "markerStart": "",
  "mask": "",
  "maskClip": "",
  "maskComposite": "",
  "maskImage": "",
  "maskMode": "",
  "maskOrigin": "",
  "maskPosition": "",
  "maskRepeat": "",
  "maskSize": "",
  "maskType": "",
  "mathDepth": "",
  "mathShift": "",
  "mathStyle": "",
  "maxBlockSize": "",
  "maxHeight": "",
  "maxInlineSize": "",
  "maxWidth": "",
  "minBlockSize": "",
  "minHeight": "",
  "minInlineSize": "",
  "minWidth": "",
  "mixBlendMode": "",
  "navigation": "",
  "negative": "",
  "objectFit": "",
  "objectPosition": "",
  "objectViewBox": "",
  "offset": "",
  "offsetAnchor": "",
  "offsetDistance": "",
  "offsetPath": "",
  "offsetPosition": "",
  "offsetRotate": "",
  "opacity": "",
  "order": "",
  "orphans": "",
  "outline": "",
  "outlineColor": "",
  "outlineOffset": "",
  "outlineStyle": "",
  "outlineWidth": "",
  "overflow": "",
  "overflowAnchor": "",
  "overflowClipMargin": "",
  "overflowWrap": "",
  "overflowX": "",
  "overflowY": "",
  "overlay": "",
  "overrideColors": "",
  "overscrollBehavior": "",
  "overscrollBehaviorBlock": "",
  "overscrollBehaviorInline": "",
  "overscrollBehaviorX": "",
  "overscrollBehaviorY": "",
  "pad": "",
  "padding": "",
  "paddingBlock": "",
  "paddingBlockEnd": "",
  "paddingBlockStart": "",
  "paddingBottom": "",
  "paddingInline": "",
  "paddingInlineEnd": "",
  "paddingInlineStart": "",
  "paddingLeft": "",
  "paddingRight": "",
  "paddingTop": "",
  "page": "",
  "pageBreakAfter": "",
  "pageBreakBefore": "",
  "pageBreakInside": "",
  "pageOrientation": "",
  "paintOrder": "",
  "perspective": "",
  "perspectiveOrigin": "",
  "placeContent": "",
  "placeItems": "",
  "placeSelf": "",
  "pointerEvents": "",
  "position": "",
  "positionAnchor": "",
  "positionTry": "",
  "positionTryOptions": "",
  "positionTryOrder": "",
  "positionVisibility": "",
  "prefix": "",
  "quotes": "",
  "r": "",
  "range": "",
  "resize": "",
  "right": "",
  "rotate": "",
  "rowGap": "",
  "rubyPosition": "",
  "rx": "",
  "ry": "",
  "scale": "",
  "scrollBehavior": "",
  "scrollMargin": "",
  "scrollMarginBlock": "",
  "scrollMarginBlockEnd": "",
  "scrollMarginBlockStart": "",
  "scrollMarginBottom": "",
  "scrollMarginInline": "",
  "scrollMarginInlineEnd": "",
  "scrollMarginInlineStart": "",
  "scrollMarginLeft": "",
  "scrollMarginRight": "",
  "scrollMarginTop": "",
  "scrollPadding": "",
  "scrollPaddingBlock": "",
  "scrollPaddingBlockEnd": "",
  "scrollPaddingBlockStart": "",
  "scrollPaddingBottom": "",
  "scrollPaddingInline": "",
  "scrollPaddingInlineEnd": "",
  "scrollPaddingInlineStart": "",
  "scrollPaddingLeft": "",
  "scrollPaddingRight": "",
  "scrollPaddingTop": "",
  "scrollSnapAlign": "",
  "scrollSnapStop": "",
  "scrollSnapType": "",
  "scrollTimeline": "",
  "scrollTimelineAxis": "",
  "scrollTimelineName": "",
  "scrollbarColor": "",
  "scrollbarGutter": "",
  "scrollbarWidth": "",
  "shapeImageThreshold": "",
  "shapeMargin": "",
  "shapeOutside": "",
  "shapeRendering": "",
  "size": "",
  "sizeAdjust": "",
  "speak": "",
  "speakAs": "",
  "src": "",
  "stopColor": "",
  "stopOpacity": "",
  "stroke": "",
  "strokeDasharray": "",
  "strokeDashoffset": "",
  "strokeLinecap": "",
  "strokeLinejoin": "",
  "strokeMiterlimit": "",
  "strokeOpacity": "",
  "strokeWidth": "",
  "suffix": "",
  "symbols": "",
  "syntax": "",
  "system": "",
  "tabSize": "",
  "tableLayout": "",
  "textAlign": "",
  "textAlignLast": "",
  "textAnchor": "",
  "textCombineUpright": "",
  "textDecoration": "",
  "textDecorationColor": "",
  "textDecorationLine": "",
  "textDecorationSkipInk": "",
  "textDecorationStyle": "",
  "textDecorationThickness": "",
  "textEmphasis": "",
  "textEmphasisColor": "",
  "textEmphasisPosition": "",
  "textEmphasisStyle": "",
  "textIndent": "",
  "textOrientation": "",
  "textOverflow": "",
  "textRendering": "",
  "textShadow": "",
  "textSizeAdjust": "",
  "textSpacingTrim": "",
  "textTransform": "",
  "textUnderlineOffset": "",
  "textUnderlinePosition": "",
  "textWrap": "",
  "timelineScope": "",
  "top": "",
  "touchAction": "",
  "transform": "",
  "transformBox": "",
  "transformOrigin": "",
  "transformStyle": "",
  "transition": "",
  "transitionBehavior": "",
  "transitionDelay": "",
  "transitionDuration": "",
  "transitionProperty": "",
  "transitionTimingFunction": "",
  "translate": "",
  "types": "",
  "unicodeBidi": "",
  "unicodeRange": "",
  "userSelect": "",
  "vectorEffect": "",
  "verticalAlign": "",
  "viewTimeline": "",
  "viewTimelineAxis": "",
  "viewTimelineInset": "",
  "viewTimelineName": "",
  "viewTransitionClass": "",
  "viewTransitionName": "",
  "visibility": "",
  "webkitAlignContent": "",
  "webkitAlignItems": "",
  "webkitAlignSelf": "",
  "webkitAnimation": "",
  "webkitAnimationDelay": "",
  "webkitAnimationDirection": "",
  "webkitAnimationDuration": "",
  "webkitAnimationFillMode": "",
  "webkitAnimationIterationCount": "",
  "webkitAnimationName": "",
  "webkitAnimationPlayState": "",
  "webkitAnimationTimingFunction": "",
  "webkitAppRegion": "",
  "webkitAppearance": "",
  "webkitBackfaceVisibility": "",
  "webkitBackgroundClip": "",
  "webkitBackgroundOrigin": "",
  "webkitBackgroundSize": "",
  "webkitBorderAfter": "",
  "webkitBorderAfterColor": "",
  "webkitBorderAfterStyle": "",
  "webkitBorderAfterWidth": "",
  "webkitBorderBefore": "",
  "webkitBorderBeforeColor": "",
  "webkitBorderBeforeStyle": "",
  "webkitBorderBeforeWidth": "",
  "webkitBorderBottomLeftRadius": "",
  "webkitBorderBottomRightRadius": "",
  "webkitBorderEnd": "",
  "webkitBorderEndColor": "",
  "webkitBorderEndStyle": "",
  "webkitBorderEndWidth": "",
  "webkitBorderHorizontalSpacing": "",
  "webkitBorderImage": "",
  "webkitBorderRadius": "",
  "webkitBorderStart": "",
  "webkitBorderStartColor": "",
  "webkitBorderStartStyle": "",
  "webkitBorderStartWidth": "",
  "webkitBorderTopLeftRadius": "",
  "webkitBorderTopRightRadius": "",
  "webkitBorderVerticalSpacing": "",
  "webkitBoxAlign": "",
  "webkitBoxDecorationBreak": "",
  "webkitBoxDirection": "",
  "webkitBoxFlex": "",
  "webkitBoxOrdinalGroup": "",
  "webkitBoxOrient": "",
  "webkitBoxPack": "",
  "webkitBoxReflect": "",
  "webkitBoxShadow": "",
  "webkitBoxSizing": "",
  "webkitClipPath": "",
  "webkitColumnBreakAfter": "",
  "webkitColumnBreakBefore": "",
  "webkitColumnBreakInside": "",
  "webkitColumnCount": "",
  "webkitColumnGap": "",
  "webkitColumnRule": "",
  "webkitColumnRuleColor": "",
  "webkitColumnRuleStyle": "",
  "webkitColumnRuleWidth": "",
  "webkitColumnSpan": "",
  "webkitColumnWidth": "",
  "webkitColumns": "",
  "webkitFilter": "",
  "webkitFlex": "",
  "webkitFlexBasis": "",
  "webkitFlexDirection": "",
  "webkitFlexFlow": "",
  "webkitFlexGrow": "",
  "webkitFlexShrink": "",
  "webkitFlexWrap": "",
  "webkitFontFeatureSettings": "",
  "webkitFontSmoothing": "",
  "webkitHyphenateCharacter": "",
  "webkitJustifyContent": "",
  "webkitLineBreak": "",
  "webkitLineClamp": "",
  "webkitLocale": "",
  "webkitLogicalHeight": "",
  "webkitLogicalWidth": "",
  "webkitMarginAfter": "",
  "webkitMarginBefore": "",
  "webkitMarginEnd": "",
  "webkitMarginStart": "",
  "webkitMask": "",
  "webkitMaskBoxImage": "",
  "webkitMaskBoxImageOutset": "",
  "webkitMaskBoxImageRepeat": "",
  "webkitMaskBoxImageSlice": "",
  "webkitMaskBoxImageSource": "",
  "webkitMaskBoxImageWidth": "",
  "webkitMaskClip": "",
  "webkitMaskComposite": "",
  "webkitMaskImage": "",
  "webkitMaskOrigin": "",
  "webkitMaskPosition": "",
  "webkitMaskPositionX": "",
  "webkitMaskPositionY": "",
  "webkitMaskRepeat": "",
  "webkitMaskSize": "",
  "webkitMaxLogicalHeight": "",
  "webkitMaxLogicalWidth": "",
  "webkitMinLogicalHeight": "",
  "webkitMinLogicalWidth": "",
  "webkitOpacity": "",
  "webkitOrder": "",
  "webkitPaddingAfter": "",
  "webkitPaddingBefore": "",
  "webkitPaddingEnd": "",
  "webkitPaddingStart": "",
  "webkitPerspective": "",
  "webkitPerspectiveOrigin": "",
  "webkitPerspectiveOriginX": "",
  "webkitPerspectiveOriginY": "",
  "webkitPrintColorAdjust": "",
  "webkitRtlOrdering": "",
  "webkitRubyPosition": "",
  "webkitShapeImageThreshold": "",
  "webkitShapeMargin": "",
  "webkitShapeOutside": "",
  "webkitTapHighlightColor": "",
  "webkitTextCombine": "",
  "webkitTextDecorationsInEffect": "",
  "webkitTextEmphasis": "",
  "webkitTextEmphasisColor": "",
  "webkitTextEmphasisPosition": "",
  "webkitTextEmphasisStyle": "",
  "webkitTextFillColor": "",
  "webkitTextOrientation": "",
  "webkitTextSecurity": "",
  "webkitTextSizeAdjust": "",
  "webkitTextStroke": "",
  "webkitTextStrokeColor": "",
  "webkitTextStrokeWidth": "",
  "webkitTransform": "",
  "webkitTransformOrigin": "",
  "webkitTransformOriginX": "",
  "webkitTransformOriginY": "",
  "webkitTransformOriginZ": "",
  "webkitTransformStyle": "",
  "webkitTransition": "",
  "webkitTransitionDelay": "",
  "webkitTransitionDuration": "",
  "webkitTransitionProperty": "",
  "webkitTransitionTimingFunction": "",
  "webkitUserDrag": "",
  "webkitUserModify": "",
  "webkitUserSelect": "",
  "webkitWritingMode": "",
  "whiteSpace": "",
  "whiteSpaceCollapse": "",
  "widows": "",
  "width": "100px",
  "willChange": "",
  "wordBreak": "",
  "wordSpacing": "",
  "wordWrap": "",
  "writingMode": "",
  "x": "",
  "y": "",
  "zIndex": "",
  "zoom": ""
  }

### 클래스 조작

- 요소의 class 어트리뷰트를 조작하여 다른 스타일을 적용
- class 어트리뷰트에 대응하는 DOM 프로퍼티인 className,classList를 통해 적용

`className`

- getter,setter
- 참조시 class 어트리뷰트의 값을 문자열로 반환
- class가 여러개면 공백으로 구분된 문자열이 반환되어 다루기가 불편

```jsx
<!DOCTYPE html>
<html>
  <head>
    <style>
      .box{
        width: 100px;
        height: 100px;
      }
      .green{
        background-color: green;
      }
    </style>
  </head>
  <body>
    <div class="box green"></div>
    <script>
      const $div = document.querySelector('div');
      console.log($div.className); // box green
    </script>
  </body>
</html>
```

**`classList`**

- Element.prototype.classList
- class 어트리뷰트의 정보를 DOMTokenList 객체에 담아 반환
- DOMTokenList 객체는 여러가지 메서드 제공
  **`DOMTokenList 객체의 메서드`**
  - add(...className) : 인수로 전달한 문자열을 class 어트리뷰트에 추가
  - remove(...className) : 삭제, 인수로 전달한 값이 없어도 에러 발생X
  - item(index) : index에 해당하는 클래스를 반환
  - contains(className) : true/false 반환
  - replace(oldClassName,newClassName)
  - toggle(className,[조건식]) : 있으면 삭제, 없으면 추가조건식은 선택사항, true면 강제로 추가, false면 강제 삭제

**`요소에 적용되어 있는 CSS 스타일 참조`**

- style 프로퍼티는 인라인 스타일만 반환
- 클래스나 상속을 통해 적용된 스타일을 알 수 없음
- 요소에 적용된 모든 스타일을 참조해야 하면 getComputedStyle 메서드로 참조
- window.getComputedStyle(element)
