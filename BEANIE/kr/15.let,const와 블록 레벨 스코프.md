    

## 15. let, const 키워드와 블록 레벨 스코프

`**변수 중복 선언 허용**`

- `var` 키워드로 선언한 변수는 중복 선언이 가능
- 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것 처럼 동작함.
    - 초기화 문이 없는 변수는 무시

```jsx
var x = 1;
var y = 1;
// 초기화문이 있는 변수 선언문
var x = 100;
// 초기화문이 없는 변수 선언문
var y;
console.log(x); // 100
console.log(y); // 1
```

`**함수 레벨 스코프**`

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정함.
    - 함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됨.

```jsx
var x = 1;
if(true) {
    var x = 10;
}
console.log(x); // 10
```

- 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높이고,
- 의도치 않게 전역 변수가 중복 선언되는 경우 발생

`**변수 호이스팅**`

- var 키워드로 선언한 변수는 변수 선언문 이전에 참조 가능
    - 변수 선언문이 스코프의 선두로 끌어 올려진 것 처럼 동작함.
- 변수 선언문 이전에 변수를 참조하는 것이 에러를 발생시키지는 않지만
    - 프로그램의 흐름상 맞지 않음
    - 가독성 저하
    - 오류 여지

## 15.2. let 키워드

`변수 중복 선언 금지`

- let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러 발생

`**블록 레벨 스코프**`

- let 키워드로 선언한 변수는 
**모든 코드 블록**을 **지역 스코프로 인정**하는 **블록 레벨 스코프**를 따름
    - 코드 블록 ( 함수, if문, for문, while문, try/catch문)
    
    ```jsx
    let foo = 1; // 전역 변수
    {
        let foo = 2; // 지역 변수
        let bar = 3; // 지역 변수
    }
    console.log(foo); // 1
    console.log(bar); // ReferenceError
    
    ```
    

`**변수 호이스팅**`

- let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작

```jsx
console.log(foo);	// ReferenceError: foo is not defined
let foo;
```

- var로 선언한 변수는 런타임 이전 자바스크립트 엔진에 의해 암묵적으로 선언 단계와 초기화 단계가 한 번에 진행 됨
    - 변수 선언문 이전에 변수에 접근해도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않고 undefined를 반환
- let 키워드로 선언한 변수는 선언 단계과 초기화 단계 분분리되어 진행
    - 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 진행되지만, 
    초기화 단계는 변수 선언문에 도달했을 때 실행
    - 초기화 단계 이전에 변수에 접근하려고 하면 참조 에러 발생
- `**일시적 사각지대**` 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간
- 호이스팅이 발생하지 않는 것처럼 보이지만 실제로는 그렇지 않음.

`**전역 객체와 let**`

- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님
    - let 전역 변수는 보이지 않는 개념적인 블록 
    (전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재

## 15.3. const 키워드

- 상수를 선언하기 위해 사용하지만 반드시 상수만을 위해 사용하진 않음

`**선언과 초기화**`

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화
- 블록 레벨 스코프
- 변수 호이스팅이 발생하지 않는 것 처럼 동작

`**재할당 금지**`

- const 키워드로 선언한 변수는 재할당 금지

`**상수**`

- const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값
- const 키워드에 의해 재할당이 금지되어 할당된 값을 변경할 수 있는 방법 없음
- 상수의 이름은 대문자와 언더스코어로 상수임을 명확히 나타내기 MY_NAME

`**const 키워드와 객체**`

- const 키워드로 선언된 변수에 객체를 할당한 경우 값 변경 가능
    - 변경 불가능한 값인 원시 값은 재할당 없이 변경 불가능
    - 변경 가능한 값인 객체는 재할당 없이도 직접 변경 가능하므로
    - 객체가 변경되어도 **변수에 할당된 참조 값은 변경되지 않음**
- const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않음

### 15.4. `var` vs `let` vs  `const`

- `**const**`
    - 변수 선언에는 기본적으로 const 사용
- `**let`**
    - 재할당이 필요한 경우에 한정해서 사용
    - 변수의 스코프는 최대한 좁게 만들기
- `**var**`
    - ES6를 사용한다면 사용하지 않음