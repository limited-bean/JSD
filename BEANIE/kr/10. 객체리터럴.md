# 10장. 객체 리터럴

### 10.1. 객체란?

---

- 자바스크립트는 객체 기반 프로그래밍 언어
- 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체
  | 원시 타입             | 객체 타입                                                                           |
  | --------------------- | ----------------------------------------------------------------------------------- |
  | primitive type        | object                                                                              |
  | reference type        |
  | 단 하나의 값만 나타냄 | 다양한 타입의 값(원시 값 또는 다른 객체) 을 하나의 단위로 구성한 복합적인 자료 구조 |
  | 변경 불가능한 값      |
  | (immutable value)     | 변경 가능한 값                                                                      |
  | ( mutable value)      |

`객체`

`프로퍼티` : 객체의 상태를 나타내는 값 (data)

`메서드` : 프로퍼티를 참조하고 동작할 수 있는 동작 (behavior)

- 0개 이상의 프로퍼티 구성된 집합
- 프로퍼티는 키(key) 값(value)로 구성
  ```jsx
  var person = {
    name: "Lee", // 프로퍼티
    age: 20, // age: 프로퍼티 키 , 20: 프로퍼티 값
  };
  ```
  - 자바스크립트의 모든 값은 프로퍼티가 될 수 있음
  - 자바스크립트의 함수는 일급 객체이므로 프로퍼티 값으로 사용 가능
    ⇒ 이 경우 일반 함수와 구분하기 위해서 **메서드**라고 부름
  ```jsx
  var counter = {
    num: 0, //이건 프로퍼티
    increase: function () {
      this.num++;
    }, // 이 함수는 메서드
  };
  ```

### 10.2. 객체 리터럴에 의한 객체 생성

- `인스턴스` : 클래스에 의해 생성되어 메모리에 저장된 실체

  - 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념.
    클래스 ⇒ 인스턴스 생성을 위한 템플릿
    인스턴스 ⇒ 객체가 메모리에 저장되어 실제로 존재하는 것

- 자바스크립트는 다양한 객체 생성 방법 지원
  1. **`객체리터럴`** 2. Object 생성자 함수 3. 생성자 함수 4. Object.create 함수 5. 클래스 (ES6)
  - 가장 일반적이고 간단한 방법으로 객체 리터럴을 사용함.
    - `({…})` 객체 중괄호 내에 0개 이상의 객체 프로퍼티 정의
  ```jsx
  var person = {
    name: "Lee",
    sayHello: function () {
      console.log(`Hello, this is ${this.name}`);
    },
  };

  //{name: "Lee", sayHello: f}
  ```
  - 프로퍼티를 정의하지 않으면 빈 객체가 생성 됨.
  ```jsx
  var empty = {};
  console.log(typeof empty); //object
  ```
  - `주의`
    - 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음
      ⇒ 값으로 평가되는 표현식이기 때문에 중괄호 뒤에 세미콜론 붙음

### 10.3. 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성
- 프로퍼티 나열은 쉼표로 구분

```jsx
var person = {
  name: "Lee", // 프로퍼티
  age: 20, // age: 프로퍼티 키 , 20: 프로퍼티 값
};
```

- 프로퍼티 키 : 빈 문자열을 포함하는 모든 `문자열` 또는 `심벌` 값
  - 프토퍼티 값에 접근할 수 있는 이름
  - 식별자 역할
    (””로 묶어도 안묶어도 괜찮지만, 네이밍 규칙을 위반하는 네이밍은 묶어주기)
  - 빈 문자열로 사용해도 에러는 없지만 키로서의 의미가 없어 지양
  - 예약어로 사용해도 에러는 없으나 발생 가능성이 있으므로 지양
  - 문자열 혹은 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 됨
  - 중복 선언 시 에러는 없으나 나중에 선언한 프로퍼티가 덮어쓰므로 주의.
- 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값

### 10.4. 메서드

- 자바스크립트 함수는 객체.
- 함수는 값으로 사용 가능하므로 프로퍼티 갑승로 사용 가능함.
  ⇒ 이 경우 메서드라고 부름

```jsx
var circle = {
  radius: 5,

  getDiameter: function () {
    return 2 * this.radius; //this는 circle
  },
};

console.log(circle.getDiameter()); //10
```

### 10.5. 프로퍼티 접근

1. `마침표 표기법`

   ```jsx
   var person = {
     name: "Lee",
   };

   person.name; //Lee
   ```

2. `대괄호 표기법`

   - 프로퍼티 키는 반드시 따옴표로 감싼 문자열. ( 식별자로 해석할 수도 있음 )
     - 네이밍 규칙을 준수하지 않는 프로퍼티 키라면 반드시 대괄호 표기법 쓰기

   ```jsx
   var person = {
     name: "Lee",
   };

   person["name"]; //Lee
   ```

- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환.

### 10.6. 프로퍼티 값 갱신

- 존재하는 프로퍼티에 값 할당시 값이 갱신 됨

```jsx
var person = {
  name: "Lee",
};

person.name = "Kwon";

person; // {name: "Kwon"}
```

### 10.7. 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값 할당시 동적으로 생상되어 추가되고 값이 할당 됨

```jsx
var person = {
  name: "Lee",
};

person.age = 18;

person; // {name: "Kwon", age: 20}
```

### 10.8. 프로퍼티 동적 생성

- delete 연산자로 삭제.
  - 존재하지 않는 값일 경우 에러 없이 무시

```jsx
var person = {
  name: "Lee",
};

person.age = 18;

delete person.age; // 삭제
delete person.address; // 에러 X

person; // {name: "Kwon"}
```

### 10.9. ES6에 추가 된 객체 리터럴 확장

**10.9.1. 프로퍼티 축약 표현**

- 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티키 생략

```jsx
let x = 1,
  y = 2;

const obj = { x, y };

obj; // { x=1; y=2 }
```

**10.9.2. 계산된 프로퍼티 명**

- 값으로 평가되는 표현식으로 프로퍼티 키 동적 생성 가능
- _단, 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 함_

```jsx
const prefix = "prop";

let i = 0;

const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

obj; // {prop-1: 1, prop-2: 2, prop-3: 3}
```

**10.9.3. 메서드 축약 표현**

- function 키워드를 생략한 축약 표현 사용 가능
  - 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작함.. 26.2 메서드에서 더보기

```jsx
const obj = {
  name: "Lee",
  sayHi() {
    console.log("Hi! " + this.name);
  },
};

obj.sayHi(); //Hi! Lee
```
